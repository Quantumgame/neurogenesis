from __future__ import division
import argparse
from collections import Iterable

import numpy as np
import matplotlib.pyplot as plt
import pylab
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
import scipy
import scipy.stats as stats
from glob import glob
from pprint import pprint as pp
from synaptogenesis.function_definitions import *

parser = argparse.ArgumentParser(
    description='Module to analyse the quality of the topographic maps generated by SpiNNaker')
parser.add_argument('path', help='path of .npz archive', nargs='*')
parser.add_argument('-o', '--output', type=str,
                    help="name of the numpy archive storing simulation results",
                    dest='filename')
parser.add_argument('--plot', help="display plots",
                    action="store_true")

parser.add_argument('-r', '--resolution', dest="resolution", type=int,
                    help='grid resolution used to resolve preferred location',
                    default=1)
args = parser.parse_args()

# Wiring
n = 16
N_layer = n ** 2
S = (n, n)
# S = (256, 1)
grid = np.asarray(S)


def pol2cart(theta, rho):
    x = rho * np.cos(theta)
    y = rho * np.sin(theta)
    return x, y


def radial_sample(in_matrix, samplenum):
    _, insize = in_matrix.shape
    centre = int(insize / 2. + .5 - 1)
    sampleradius = np.floor(insize / 2.)
    out = np.zeros(int(sampleradius))
    angles = np.linspace(0, 2 * np.pi, 100)
    dists = np.arange(0, sampleradius)
    for angle in angles:
        for dist in dists:
            tempx, tempy = pol2cart(angle, dist)
            yceil = int(np.ceil(tempy))
            yfloor = int(np.floor(tempy))
            xceil = int(np.ceil(tempx))
            xfloor = int(np.floor(tempx))
            if yceil == yfloor:
                if xceil == xfloor:
                    sample = in_matrix[
                        int(yceil + centre), int(xceil + centre)]
                else:
                    sample = in_matrix[yceil + centre, xfloor + centre] * \
                             np.mod(tempx, 1) + in_matrix[
                                                    yceil + centre, xceil + centre] * \
                                                (1 - np.mod(tempx, 1))
            else:
                if xceil == xfloor:
                    sample = in_matrix[yfloor + centre, xceil + centre] * \
                             np.mod(tempy, 1) + in_matrix[
                                                    yceil + centre, xceil + centre] * \
                                                (1 - np.mod(tempy, 1))
                else:
                    yfloorsample = in_matrix[
                                       yfloor + centre, xfloor + centre] * \
                                   np.mod(tempx, 1) + in_matrix[
                                                          yfloor + centre, xceil + centre] * \
                                                      (1 - np.mod(tempx, 1))
                    yceilsample = in_matrix[
                                      yceil + centre, xfloor + centre] * np.mod(
                        tempx, 1) + in_matrix[
                                        yceil + centre, xceil + centre] * (
                                        1 - np.mod(tempx, 1))
                    sample = yfloorsample * np.mod(tempy, 1) + yceilsample * (
                        1 - np.mod(tempy, 1))
            out[int(dist)] = out[int(dist)] + sample
    return out / float(samplenum)


# Function definitions
def conn_matrix_to_fan_in(conn_matrix, mode):
    conn_matrix = np.copy(conn_matrix)
    ys = int(np.sqrt(conn_matrix.shape[0]))
    xs = int(np.sqrt(conn_matrix.shape[1]))
    fan_in = np.zeros((ys ** 2, xs ** 2))
    locations = np.asarray(np.where(np.isfinite(conn_matrix)))

    for row in range(ys):
        for column in range(xs):
            if 'conn' in mode:
                fan_in[ys * row:ys * (row + 1),
                xs * column: xs * (column + 1)] = np.nan_to_num(
                    conn_matrix[:, row * xs + column].reshape(16, 16)) / g_max
            else:
                fan_in[ys * row:ys * (row + 1),
                xs * column: xs * (column + 1)] = np.nan_to_num(
                    conn_matrix[:, row * xs + column].reshape(16, 16))
    return fan_in


def centre_weights(in_star_all, n1d):
    in_star_all = np.copy(in_star_all)
    half_range = n1d // 2
    mean_projection = np.zeros((n1d + 1, n1d + 1))
    mean_centred_projection = np.zeros((n1d + 1, n1d + 1))
    positions = np.arange(-half_range, half_range + 1)
    means_and_std_devs = np.zeros((n1d ** 2, 8))
    means_for_plot = np.ones((n1d ** 2 * 2 - 1, 2)) * np.nan
    std_devs_xs = np.zeros(n1d)
    std_devs_ys = np.zeros(n1d)
    std_devs_xs_fine = np.zeros(11)
    std_devs_ys_fine = np.zeros(11)

    for y in range(n1d):
        for x in range(n1d):
            in_star = np.copy(
                in_star_all[y * n1d:(y + 1) * n1d, x * n1d:(x + 1) * n1d])
            in_star_extended = np.tile(in_star, [3, 3])
            if np.sum(in_star) > 0:
                # Add to the mean projection
                ideal_centred = np.copy(in_star_extended[
                                        n1d + y - half_range: n1d + y + half_range + 1,
                                        n1d + x - half_range:n1d + x + half_range + 1])
                ideal_centred[0, :] = ideal_centred[0, :] / 2.
                ideal_centred[n1d, :] = ideal_centred[n1d, :] / 2.
                ideal_centred[:, 0] = ideal_centred[:, 0] / 2.
                ideal_centred[:, n1d] = ideal_centred[:, n1d] / 2.

                mean_projection += ideal_centred

                #  ^^ So far so good ^^
                # Find the coarse centre of mass
                for pos in range(n1d):
                    temp_centred = np.copy(in_star_extended[
                                           n1d + pos - half_range: n1d + pos + half_range + 1,
                                           n1d + pos - half_range:n1d + pos + half_range + 1])
                    # correct the edges of centred
                    temp_centred[0, :] = temp_centred[0, :] / 2.
                    temp_centred[n1d, :] = temp_centred[n1d, :] / 2.
                    temp_centred[:, 0] = temp_centred[:, 0] / 2.
                    temp_centred[:, n1d] = temp_centred[:, n1d] / 2.
                    # calculate the StdDev
                    centred_x = np.sum(temp_centred, axis=0)
                    centred_y = np.sum(temp_centred, axis=1)
                    std_devs_xs[pos] = np.sqrt(
                        np.sum(centred_x * (positions ** 2)) / np.sum(
                            centred_x));
                    std_devs_ys[pos] = np.sqrt(
                        np.sum(centred_y * (positions ** 2)) / np.sum(
                            centred_y));

                std_dev_x = np.min(std_devs_xs)
                pos_x = np.argmin(std_devs_xs)
                std_dev_y = np.min(std_devs_ys)
                pos_y = np.argmin(std_devs_ys)

                #                 print pos_x, pos_y
                #                 print std_dev_x, std_dev_y



                # reconstruct the coarsely centred receptive field
                centred_coarse = np.copy(in_star_extended[
                                         n1d + pos_y - half_range:n1d + pos_y + half_range + 1,
                                         n1d + pos_x - half_range:n1d + pos_x + half_range + 1])
                centred_coarse[0, :] = centred_coarse[0, :] / 2.
                centred_coarse[n1d, :] = centred_coarse[n1d, :] / 2.
                centred_coarse[:, 0] = centred_coarse[:, 0] / 2.
                centred_coarse[:, n1d] = centred_coarse[:, n1d] / 2.

                for pos_fine in np.linspace(-.5, .5, 11):
                    assert std_devs_xs[
                               pos_x] == std_dev_x, "{0} != {1}".format(
                        std_devs_xs[pos_x], std_dev_x)
                    assert std_devs_ys[
                               pos_y] == std_dev_y, "{0} != {1}".format(
                        std_devs_ys[pos_y], std_dev_y)

                    temp_centred_fine = np.copy(in_star_extended[
                                                n1d + pos_y - half_range: n1d + pos_y + half_range + 1,
                                                n1d + pos_x - half_range:n1d + pos_x + half_range + 1])
                    # correct the edges of centred
                    temp_centred_fine[0, :] = temp_centred_fine[0, :] * (
                        .5 - pos_fine)
                    temp_centred_fine[n1d, :] = temp_centred_fine[n1d, :] * (
                        .5 + pos_fine)
                    temp_centred_fine[:, 0] = temp_centred_fine[:, 0] * (
                        .5 - pos_fine)
                    temp_centred_fine[:, n1d] = temp_centred_fine[:, n1d] * (
                        .5 + pos_fine)

                    # calculate the StdDev
                    centred_x = np.sum(temp_centred_fine, axis=0)
                    centred_y = np.sum(temp_centred_fine, axis=1)
                    positions_fine = np.arange(-half_range,
                                               half_range + 1) - pos_fine
                    positions_fine = positions_fine.flatten()
                    std_devs_xs_fine[
                        int(np.round(pos_fine * 10) + 5)] = np.sqrt(
                        np.sum(centred_x * (positions_fine ** 2)) / np.sum(
                            centred_x))
                    std_devs_ys_fine[
                        int(np.round(pos_fine * 10) + 5)] = np.sqrt(
                        np.sum(centred_y * (positions_fine ** 2)) / np.sum(
                            centred_y))

                # assert np.isclose(std_dev_x, std_devs_xs_fine[5]), "{0} != {1}".format(
                #     std_dev_x, std_devs_xs_fine[5])
                # assert np.isclose(std_dev_y, std_devs_ys_fine[5]), "{0} != {1}".format(
                #     std_dev_y, std_devs_ys_fine[5])
                std_dev_x = np.min(std_devs_xs_fine)
                pos_x_fine = np.argmin(std_devs_xs_fine)
                std_dev_y = np.min(std_devs_ys_fine)
                pos_y_fine = np.argmin(std_devs_ys_fine)
                pos_x_fine = (pos_x_fine - 5) / 10.
                pos_y_fine = (pos_y_fine - 5) / 10.

                # reconstruct the finely centred receptive field
                # and add to the mean centred projection
                second_to_first_indices = np.concatenate(
                    (np.arange(1, n1d + 1), [0]))
                last_to_first_indices = np.concatenate(
                    ([n1d], np.arange(0, n1d))) # checked

                centred_left = centred_coarse[:, second_to_first_indices]
                centred_right = centred_coarse[:, last_to_first_indices]
                centred_fine_x = centred_left * np.max([0., -pos_x_fine]) + \
                                 centred_coarse * (1. - np.abs(pos_x_fine)) + \
                                 centred_right * np.max([0., pos_x_fine])

                centred_up = centred_fine_x[second_to_first_indices, :]
                centred_down = centred_fine_x[last_to_first_indices, :]
                centred_fine = centred_up * np.max([0., -pos_y_fine]) + \
                               centred_fine_x * (1. - np.abs(pos_y_fine)) + \
                               centred_down * np.max([0., pos_y_fine])

                mean_centred_projection += centred_fine

                std_dev = np.mean([std_dev_x, std_dev_y])
                mean_x = pos_x + pos_x_fine - x
                mean_y = pos_y + pos_y_fine - y
                if mean_x > half_range:
                    mean_x = mean_x - n1d
                if mean_x < -half_range:
                    mean_x = mean_x + n1d
                if mean_y > half_range:
                    mean_y = mean_y - n1d
                if mean_y < -half_range:
                    mean_y = mean_y + n1d
                mean_dist = np.sqrt(mean_x ** 2 + mean_y ** 2)
            else:
                mean_x = 0
                mean_y = 0
                mean_dist = 0
                std_dev = 0
            # For quiver plots
            if mean_dist == 0:
                means_and_std_devs[y * n1d + x, :] = np.asarray(
                    [x, y, mean_x, mean_y, mean_dist, std_dev, 0, 0])
            else:
                means_and_std_devs[y * n1d + x, :] = np.asarray(
                    [x, y, mean_x, mean_y, mean_dist, std_dev,
                     mean_x / mean_dist, mean_y / mean_dist])
                # For mapping plots
                Y = y + 1
                X = x + 1

                means_for_plot[(Y - 1) * n1d + X * np.remainder(Y, 2) +
                               (n1d + 1 - X) * np.remainder(Y - 1, 2) - 1, :] = [X + mean_x, Y + mean_y]
                means_for_plot[(X - 1) * n1d + Y * np.remainder(X - 1, 2) + (n1d + 1 - Y) * np.remainder(
                    X,2) + n1d ** 2 - 1 - 1, :] = [X + mean_x, Y + mean_y]
                #     return (mean_projection/(n1d**2), std_dev)
    mean_projection = mean_projection / (n1d ** 2.)
    mean_centred_projection /= (n1d ** 2.)
    return (mean_projection, means_and_std_devs, means_for_plot,
            mean_centred_projection)


def fan_in(conn, weight, mode, area):
    conn = np.copy(conn).astype(np.int32)
    if 'rec' in area:
        conn[conn <= 255] = -1
    if 'ff' in area:
        conn[conn > 255] = -1
    output = np.zeros((256, 256))

    for syn in range(conn.shape[0]):
        for post_x in range(16):
            for post_y in range(16):
                pre_loc = int(conn[syn, post_x * 16 + post_y])
                if pre_loc >= 0:
                    pre_loc = np.mod(pre_loc, 256)
                    pre_x = int(np.floor(pre_loc / 16.))
                    pre_y = np.mod(pre_loc, 16)
                    #                     print pre_x, pre_y, post_x, post_y
                    #                     break
                    if 'conn' in mode:
                        output[post_x * 16 + pre_x, post_y * 16 + pre_y] += 1
                    else:
                        output[post_x * 16 + pre_x, post_y * 16 + pre_y] += \
                            weight[syn, post_x * 16 + post_y]
    return output


def distance(x0, x1, grid=np.asarray([16, 16]), type='euclidian'):
    x0 = np.asarray(x0)
    x1 = np.asarray(x1)
    delta = np.abs(x0 - x1)
    delta = np.where(delta > grid * .5, delta - grid, delta)

    if type == 'manhattan':
        return np.abs(delta).sum(axis=-1)
    return np.sqrt((delta ** 2).sum(axis=-1))


def weight_shuffle(conn, weights, area):
    weights_copy = weights.copy()
    for post_id in range(weights_copy.shape[1]):
        pre_ids = conn[:, post_id]
        pre_weights = weights_copy[:, post_id]
        within_row_filter = np.argwhere(
            np.logical_and(pre_ids >= 0, pre_ids <= 255))
        permutation = np.random.permutation(within_row_filter)
        for index in range(within_row_filter.size):
            weights_copy[permutation[index], post_id] = weights[
                within_row_filter[index], post_id]

    return weights_copy


def list_to_post_pre(ff_list, lat_list, s_max, N_layer):
    conn = np.ones((s_max * 2, N_layer)) * -1
    weight = np.zeros((s_max * 2, N_layer))

    for target in range(N_layer):
        # source ids
        ff_pre_ids = ff_list[ff_list[:, 1] == target][:, 0]
        lat_pre_ids = lat_list[lat_list[:, 1] == target][:, 0] + N_layer
        conn[:ff_pre_ids.size + lat_pre_ids.size, target] \
            = np.concatenate((ff_pre_ids, lat_pre_ids))
        # weights
        ff_pre_weights = ff_list[ff_list[:, 1] == target][:, 2]
        lat_pre_weights = lat_list[lat_list[:, 1] == target][:, 2]
        weight[:ff_pre_weights.size + lat_pre_weights.size, target] \
            = np.concatenate((ff_pre_weights, lat_pre_weights))
    return conn, weight


paths = []
for file in args.path:
    if "*" in file:
        globbed_files = glob(file)
        for globbed_file in globbed_files:
            if "npz" in globbed_file:
                paths.append(globbed_file)
    else:
        paths.append(file)
for file in paths:
    try:
        start_time = pylab.datetime.datetime.now()
        print "\n\nAnalysing file", str(file)
        data = np.load(file)
        simdata = np.array(data['sim_params']).ravel()[0]

        if 'case' in simdata:
            print "Case", simdata['case'], "analysis"
        else:
            print "Case unknown"
        simtime = int(data['simtime'])
        post_spikes = data['post_spikes']

        if not args.plot:
            total_target_neuron_mean_spike_rate = \
                post_spikes.shape[0] / float(simtime) * 1000. / N_layer

            ff_last = data['final_pre_weights']
            lat_last = data['final_post_weights']
            init_ff_weights = data['init_ff_connections']
            init_lat_weights = data['init_lat_connections']
            ff_init = data['init_ff_connections']
            lat_init = data['init_lat_connections']

            try:
                # retrieve some important sim params
                grid = simdata['grid']
                g_max = simdata['g_max']
                s_max = simdata['s_max']
                sigma_form_forward = simdata['sigma_form_forward']
                sigma_form_lateral = simdata['sigma_form_lateral']
                p_form_lateral = simdata['p_form_lateral']
                p_form_forward = simdata['p_form_forward']
                p_elim_dep = simdata['p_elim_dep']
                p_elim_pot = simdata['p_elim_pot']
                f_rew = simdata['f_rew']
            except:
                # use defaults
                grid = np.asarray([16, 16])
                s_max = 16
                sigma_form_forward = 2.5
                sigma_form_lateral = 1
                p_form_lateral = 1
                p_form_forward = 0.16
                p_elim_dep = 0.0245
                p_elim_pot = 1.36 * np.e ** -4
                f_rew = 10 ** 4  # Hz
                g_max = .2
            finally:
                data.close()

            last_conn, last_weight = list_to_post_pre(ff_last, lat_last,
                                                      s_max, N_layer)
            init_conn, init_weight = list_to_post_pre(ff_init, lat_init,
                                                      s_max, N_layer)
            #####     #####
            ## POST AREA ##
            #####     #####
            import scipy.io

            IntialConnectivity = scipy.io.loadmat(
                '2009_09_04.17_48_33 32Syn300s/InitialConnectivity.mat')
            Params = scipy.io.loadmat(
                '2009_09_04.17_48_33 32Syn300s/Params.mat')
            test_fan_in = fan_in(IntialConnectivity['ConnPostToPre'] - 1,
                                 IntialConnectivity['WeightPostToPre'],
                                 'conn',
                                 'ff')
            other_fan_in = scipy.io.loadmat("fan_in.mat")['fan_in']

            assert np.all(test_fan_in == other_fan_in)
            mean_projection, means_and_std_devs, \
            means_for_plot, mean_centred_projection = centre_weights(
                test_fan_in, 16)

            # plt.plot(means_for_plot[:, 0], means_for_plot[:, 1])
            # plt.show()
            other_means_for_plot = scipy.io.loadmat("MeansForPlot")[
                'MeansForPlot']
            # plt.plot(other_means_for_plot[:, 0], other_means_for_plot[:, 1])
            # plt.show()

            # assert np.all(np.isclose(means_for_plot, other_means_for_plot))

            test_mean_std = np.mean(means_and_std_devs[:, 5])
            test_mean_AD = np.mean(means_and_std_devs[:, 4])
            test_stds = means_and_std_devs[:, 5]
            test_AD = means_and_std_devs[:, 4]
            MeansAndStuff = scipy.io.loadmat("means_and_std_devs.mat")

            other_mean_std = np.mean(MeansAndStuff['means_and_std_devs'][:, 5])
            other_mean_AD = np.mean(MeansAndStuff['means_and_std_devs'][:, 4])
            assert other_mean_std == test_mean_std
            assert other_mean_AD == test_mean_AD

            # harder test
            MeansAndStuff['means_and_std_devs'][:, [0, 1]] -= 1
            assert np.all(
                MeansAndStuff['means_and_std_devs'] == means_and_std_devs), \
                np.argwhere(
                    MeansAndStuff['means_and_std_devs'] != means_and_std_devs)

            mean_centred_projection_matlab = \
                scipy.io.loadmat("mean_centred_projection")[
                    'MeanCentredProjection']

            # np.argwhere(~np.isclose(mean_centred_projection, mean_centred_projection_matlab))
            assert np.all(np.isclose(mean_centred_projection, mean_centred_projection_matlab, 0.001, 0.01))

            mean_projection_rad_con_init_rec = scipy.io.loadmat(
                'mean_proj_rad_con_init_rec.mat')['MeanProjRadConInitRec']

            fan_in_conn_init_rec = scipy.io.loadmat(
                'fan_in_conn_init_rec.mat')['FanInConnInitRec']

            mean_projection, means_and_std_devs, means_for_plot, mean_centred_projection = centre_weights(
                fan_in_conn_init_rec, 16)

            rad_test = radial_sample(mean_projection, 100)

            assert np.all(mean_projection_rad_con_init_rec == rad_test)

            # import pylab as plt
            # plt.bar(range(8),rad_test)
            # plt.show()
            # pass
            #####     #####
            ## POST AREA ##
            #####     #####


            number_ff_incoming_connections = ff_last.shape[0]
            final_mean_number_ff_synapses = number_ff_incoming_connections / float(
                N_layer)

            initial_weight_mean = np.mean(ff_init[:, 2])

            final_weight_mean = np.mean(ff_last[:, 2])

            final_weight_proportion = final_weight_mean / initial_weight_mean

            # a

            init_fan_in = fan_in(init_conn, init_weight, 'conn', 'ff')

            mean_projection, means_and_std_devs, means_for_plot, mean_centred_projection = centre_weights(
                init_fan_in, 16)

            init_mean_std = np.mean(means_and_std_devs[:, 5])
            init_mean_AD = np.mean(means_and_std_devs[:, 4])
            init_stds = means_and_std_devs[:, 5]
            init_AD = means_and_std_devs[:, 4]

            # b
            final_fan_in = fan_in(last_conn, last_weight, 'conn', 'ff')
            fin_mean_projection, fin_means_and_std_devs, fin_means_for_plot, fin_mean_centred_projection = centre_weights(
                final_fan_in, 16)
            fin_mean_std_conn = np.mean(fin_means_and_std_devs[:, 5])
            fin_mean_AD_conn = np.mean(fin_means_and_std_devs[:, 4])
            fin_stds_conn = fin_means_and_std_devs[:, 5]
            fin_AD_conn = fin_means_and_std_devs[:, 4]

            # c

            init_ff_connections = []
            ff_s = np.zeros(N_layer, dtype=np.uint)
            lat_s = np.zeros(N_layer, dtype=np.uint)
            existing_pre_ff = []
            generated_ff_conn = []
            generated_lat_conn = []

            generate_initial_connectivity(
                ff_s, generated_ff_conn,
                sigma_form_forward, p_form_forward,
                "\nGenerating initial feedforward connectivity...",
                N_layer=N_layer, n=n, s_max=s_max, g_max=g_max)

            generate_initial_connectivity(
                lat_s, generated_lat_conn,
                sigma_form_lateral, p_form_lateral,
                "\nGenerating initial lateral connectivity...",
                N_layer=N_layer, n=n, s_max=s_max, g_max=g_max)

            gen_init_conn, gen_init_weight = \
                list_to_post_pre(np.asarray(generated_ff_conn),
                                 np.asarray(generated_lat_conn), s_max,
                                 N_layer)

            gen_fan_in = fan_in(gen_init_conn, gen_init_weight, 'conn', 'ff')

            fin_mean_projection_shuf, fin_means_and_std_devs_shuf, \
            fin_means_for_plot_shuf, fin_mean_centred_projection_shuf = \
                centre_weights(gen_fan_in, 16)

            fin_mean_std_conn_shuf = np.mean(fin_means_and_std_devs_shuf[:, 5])
            fin_mean_AD_conn_shuf = np.mean(fin_means_and_std_devs_shuf[:, 4])
            fin_stds_conn_shuf = fin_means_and_std_devs_shuf[:, 5]
            fin_AD_conn_shuf = fin_means_and_std_devs_shuf[:, 4]

            wsr_sigma_fin_conn_fin_conn_shuffle = stats.wilcoxon(
                fin_stds_conn.ravel(), fin_stds_conn_shuf.ravel())
            wsr_AD_fin_conn_fin_conn_shuffle = stats.wilcoxon(
                fin_AD_conn.ravel(),
                fin_AD_conn_shuf.ravel())
            # d
            final_fan_in_weight = fan_in(last_conn, last_weight, 'weight',
                                         'ff')
            # final_fan_in_weight = conn_matrix_to_fan_in(ff_last, mode='weight')
            fin_mean_projection_weight, fin_means_and_std_devs_weight, fin_means_for_plot_weight, fin_mean_centred_projection_weight = centre_weights(
                final_fan_in_weight, 16)
            fin_mean_std_weight = np.mean(fin_means_and_std_devs_weight[:, 5])
            fin_mean_AD_weight = np.mean(fin_means_and_std_devs_weight[:, 4])
            fin_stds_weight = fin_means_and_std_devs_weight[:, 5]
            fin_AD_weight = fin_means_and_std_devs_weight[:, 4]

            # e

            weight_copy = weight_shuffle(last_conn, last_weight, 'ff')
            shuf_weights = fan_in(last_conn, weight_copy, 'weight', 'ff')

            fin_mean_projection_weight_shuf, fin_means_and_std_devs_weight_shuf, fin_means_for_plot_weight_shuf, fin_mean_centred_projection_weight_shuf = centre_weights(
                shuf_weights, 16)
            fin_mean_std_weight_shuf = np.mean(
                fin_means_and_std_devs_weight_shuf[:, 5])
            fin_mean_AD_weight_shuf = np.mean(
                fin_means_and_std_devs_weight_shuf[:, 4])
            fin_stds_weight_shuf = fin_means_and_std_devs_weight_shuf[:, 5]
            fin_AD_weight_shuf = fin_means_and_std_devs_weight_shuf[:, 4]

            wsr_sigma_fin_weight_fin_weight_shuffle = stats.wilcoxon(
                fin_stds_weight.ravel(), fin_stds_weight_shuf.ravel())
            wsr_AD_fin_weight_fin_weight_shuffle = stats.wilcoxon(
                fin_AD_weight.ravel(), fin_AD_weight_shuf.ravel())

            pp(simdata)
            print
            print "%-60s" % "Target neuron spike rate", total_target_neuron_mean_spike_rate, "Hz"
            print "%-60s" % "Final mean number of feedforward synapses", final_mean_number_ff_synapses
            print "%-60s" % "Weight as proportion of max", final_weight_proportion
            print "%-60s" % "Mean sigma aff init", init_mean_std
            print "%-60s" % "Mean sigma aff fin conn shuffle", fin_mean_std_conn_shuf
            print "%-60s" % "Mean sigma aff fin conn", fin_mean_std_conn
            print "%-60s" % "p(WSR sigma aff fin conn vs sigma aff fin conn shuffle)", wsr_sigma_fin_conn_fin_conn_shuffle.pvalue
            print "%-60s" % "Mean sigma aff fin weight shuffle", fin_mean_std_weight_shuf
            print "%-60s" % "Mean sigma aff fin weight", fin_mean_std_weight
            print "%-60s" % "p(WSR sigma aff fin weight vs sigma aff fin weight shuffle)", wsr_sigma_fin_weight_fin_weight_shuffle.pvalue
            print "%-60s" % "Mean AD init", init_mean_AD
            print "%-60s" % "Mean AD fin conn shuffle", fin_mean_AD_conn_shuf
            print "%-60s" % "Mean AD fin conn", fin_mean_AD_conn
            print "%-60s" % "p(WSR AD fin conn vs AD fin conn shuffle)", wsr_AD_fin_conn_fin_conn_shuffle.pvalue
            print "%-60s" % "Mean AD fin weight shuffle", fin_mean_AD_weight_shuf
            print "%-60s" % "Mean AD fin weight", fin_mean_AD_weight
            print "%-60s" % "p(WSR AD fin weight vs AD fin weight shuffle)", wsr_AD_fin_weight_fin_weight_shuffle.pvalue

            # LAT connection bar chart
            
            init_fan_in_rec = fan_in(init_conn, init_weight, 'conn', 'rec')

            mean_projection_rec, means_and_std_devs_rec, \
            means_for_plot_rec, mean_centred_projection_rec = centre_weights(
                init_fan_in_rec, 16)

            init_fan_in_rec_rad = radial_sample(mean_projection_rec, 100)

            final_fan_in_rec = fan_in(last_conn, last_weight, 'weight',
                                      'rec')

            final_mean_projection_rec, final_means_and_std_devs_rec, \
            final_means_for_plot_rec, final_mean_centred_projection_rec = centre_weights(
                final_fan_in_rec, 16)

            final_fan_in_rec_rad = \
                radial_sample(final_mean_projection_rec, 100)


            final_fan_in_rec_conn = fan_in(last_conn, last_weight, 'conn',
                                      'rec')

            final_mean_projection_rec_conn, final_means_and_std_devs_rec_conn, \
            final_means_for_plot_rec_conn, final_mean_centred_projection_rec_conn = centre_weights(
                final_fan_in_rec_conn, 16)

            final_fan_in_rec_rad_conn = \
                radial_sample(final_mean_projection_rec_conn, 100)
            
            ## FF connection bar chart

            init_fan_in_ff = fan_in(init_conn, init_weight, 'conn', 'ff')

            mean_projection_ff, means_and_std_devs_ff, \
            means_for_plot_ff, mean_centred_projection_ff = centre_weights(
                init_fan_in_ff, 16)

            init_fan_in_ff_rad = radial_sample(mean_projection_ff, 100)

            final_fan_in_ff = fan_in(last_conn, last_weight, 'weight',
                                      'ff')

            final_mean_projection_ff, final_means_and_std_devs_ff, \
            final_means_for_plot_ff, final_mean_centred_projection_ff = centre_weights(
                final_fan_in_ff, 16)

            final_fan_in_ff_rad = \
                radial_sample(final_mean_projection_ff, 100)

            final_fan_in_ff_conn = fan_in(last_conn, last_weight, 'conn',
                                           'ff')

            final_mean_projection_ff_conn, final_means_and_std_devs_ff_conn, \
            final_means_for_plot_ff_conn, final_mean_centred_projection_ff_conn = centre_weights(
                final_fan_in_ff_conn, 16)

            final_fan_in_ff_rad_conn = \
                radial_sample(final_mean_projection_ff_conn, 100)
            
            # Time stuff

            end_time = pylab.datetime.datetime.now()
            suffix = end_time.strftime("_%H%M%S_%d%m%Y")

            elapsed_time = end_time - start_time

            print "Total time elapsed -- " + str(elapsed_time)

            if args.filename:
                filename = args.filename
            else:
                filename = "analysis_" + str(suffix)

            np.savez(filename, recording_archive_name=file,
                     target_neurom_mean_spike_rate=total_target_neuron_mean_spike_rate,
                     final_mean_number_ff_synapses=final_mean_number_ff_synapses,
                     final_weight_proportion=final_weight_proportion,
                     init_ff_weights=init_ff_weights,
                     init_lat_connections=init_lat_weights,
                     final_pre_weights=ff_last,
                     final_post_weights=lat_last,
                     # a
                     init_mean_std=init_mean_std, init_stds=init_stds,
                     init_mean_AD=init_mean_AD,
                     init_AD=init_AD,
                     # b
                     fin_mean_std_conn=fin_mean_std_conn,
                     fin_stds_conn=fin_stds_conn,
                     fin_mean_AD_conn=fin_mean_AD_conn,
                     fin_AD_conn=fin_AD_conn,
                     # c
                     generated_ff_conn=generated_ff_conn,
                     fin_mean_std_conn_shuf=fin_mean_std_conn_shuf,
                     fin_stds_conn_shuf=fin_stds_conn_shuf,
                     fin_mean_AD_conn_shuf=fin_mean_AD_conn_shuf,
                     fin_AD_conn_shuf=fin_AD_conn_shuf,
                     wsr_sigma_fin_conn_fin_conn_shuffle=wsr_sigma_fin_conn_fin_conn_shuffle,
                     wsr_AD_fin_conn_fin_conn_shuffle=wsr_AD_fin_conn_fin_conn_shuffle,
                     # d
                     fin_mean_std_weight=fin_mean_std_weight,
                     fin_stds_weight=fin_stds_weight,
                     fin_mean_AD_weight=fin_mean_AD_weight,
                     fin_AD_weight=fin_AD_weight,
                     # e
                     shuf_weights=shuf_weights,
                     fin_mean_std_weight_shuf=fin_mean_std_weight_shuf,
                     fin_stds_weight_shuf=fin_stds_weight_shuf,
                     fin_mean_AD_weight_shuf=fin_mean_AD_weight_shuf,
                     fin_AD_weight_shuf=fin_AD_weight_shuf,
                     wsr_sigma_fin_weight_fin_weight_shuffle=wsr_sigma_fin_weight_fin_weight_shuffle,
                     wsr_AD_fin_weight_fin_weight_shuffle=wsr_AD_fin_weight_fin_weight_shuffle,
                     total_time=elapsed_time)

            import pylab as plt

            plt.figure()
            plt.subplot(1, 3, 1)
            plt.suptitle("Distance between input and target neurons for lateral connections")
            plt.bar(range(8), init_fan_in_rec_rad)
            plt.ylim([0, 3])
            plt.xticks(range(8))
            plt.ylabel("Weight density (normalised)")
            plt.subplot(1,3,2)
            plt.bar(range(8), final_fan_in_rec_rad)
            plt.subplot(1,3,3)
            plt.bar(range(8), final_fan_in_rec_rad_conn)
            plt.show()

            plt.figure()
            plt.subplot(1, 3, 1)
            plt.suptitle(
                "Distance between input and target neurons for feedforward connections")
            plt.bar(range(8), init_fan_in_ff_rad)
            plt.ylim([0, .5])
            plt.xticks(range(8))
            plt.ylabel("Weight density (normalised)")
            plt.subplot(1, 3, 2)
            plt.bar(range(8), final_fan_in_ff_rad)
            plt.subplot(1, 3, 3)
            plt.bar(range(8), final_fan_in_ff_rad_conn)
            plt.ylim([0, .5])
            plt.show()

            plt.figure()
            plt.subplot(1, 2, 1)
            plt.suptitle("Map formation sequence")
            plt.title("Initial map")
            plt.plot(means_for_plot[:, 0], means_for_plot[:,1])
            plt.subplot(1, 2, 2)
            plt.title("Final map")
            plt.plot(fin_means_for_plot_weight[:, 0], fin_means_for_plot_weight[:,1])
            # plt.ylabel("Weight density (normalised)")

            plt.show()



        elif args.plot:
            all_ff_connections = data['ff_connections']
            all_lat_connections = data['lat_connections']
            if data:
                data.close()
            number_of_recordings = all_ff_connections.shape[0]
            all_mean_sigmas = np.ones(number_of_recordings) * np.nan
            all_mean_ADs = np.ones(number_of_recordings) * np.nan
            for index in range(number_of_recordings):
                conn, weight = \
                    list_to_post_pre(all_ff_connections[index],
                                     all_lat_connections[index], 16,
                                     N_layer)

                current_fan_in = fan_in(conn, weight, 'weight', 'ff')
                mean_projection, means_and_std_devs, means_for_plot, mean_centred_projection = centre_weights(
                    current_fan_in, 16)

                all_mean_sigmas[index] = np.mean(means_and_std_devs[:, 5])
                all_mean_ADs[index] = np.mean(means_and_std_devs[:, 4])

                # mean_std, stds, mean_AD, AD, variances = sigma_and_ad(
                #     all_ff_connections[index, :, :],
                #     unitary_weights=False,
                #     resolution=args.resolution)
                # all_mean_sigmas[index] = mean_std
                # all_mean_ADs[index] = mean_AD
            pylab.plot(all_mean_sigmas)
            pylab.show()
            pylab.plot(all_mean_ADs)
            pylab.show()
            np.savez("last_std_ad_evo", recording_archive_name=file,
                     all_mean_sigmas=all_mean_sigmas,
                     all_mean_ads=all_mean_ADs)

    except IOError as e:
        print "IOError:", e
    except MemoryError:
        print "Out of memory. Did you use HDF5 slices to read in data?", e
