import argparse
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
import scipy

parser = argparse.ArgumentParser(
    description='Module to analyse the quality of the topographic maps generated by SpiNNaker')
parser.add_argument('path', help='path of .npz archive')

args = parser.parse_args()

data = np.load(args.path)

simtime = int(data['simtime'])
post_spikes = data['post_spikes']

count_spikes = np.zeros(256)
for id, time in post_spikes:
    count_spikes[int(id)] += 1

target_neuron_mean_spike_rate = count_spikes / float(simtime) * 1000.

total_target_neuron_mean_spike_rate = np.mean(target_neuron_mean_spike_rate)
print "Target neuron spike rate", total_target_neuron_mean_spike_rate, "Hz"

ff_last = data['final_pre_weights'].reshape(256,256)
init_ff_weights = data['init_ff_connections']
simdata = np.array(data['sim_params']).ravel()[0]

number_ff_incoming_connections = np.count_nonzero(~np.isnan(ff_last), axis=0)
final_mean_number_ff_synapses = np.mean(number_ff_incoming_connections)
print "Final mean number of feedforward synapses", final_mean_number_ff_synapses

initial_weight_mean = np.nanmean(init_ff_weights)
print "Initial weight mean", initial_weight_mean, "(obviously)"

final_weight_mean = np.nanmean(ff_last)
print "Final weight mean", final_weight_mean

print "Weight as proportion of max for the initial number of synapses", final_weight_mean  / initial_weight_mean

